<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Image Generator (DVD Logo Style) by GeminiGhostSymphony</title>
    
    <!-- EXTERNAL LIBRARIES -->
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js"></script>
    
    <style id="base-styles">
        /* CSS CORE VARIABLES */
        :root { 
            --accent: #00d4ff; --bg: #121212; --card: #1e1e1e; 
            --text: #e0e0e0; --muted: #888; --success: #28a745; --err: #ff4444; 
        }

        /* BASE LAYOUT */
        html, body { 
            height: 100%; width: 100%; margin: 0; padding: 0;
            background-color: var(--bg); overflow-y: auto; 
            font-family: 'Inter', system-ui, sans-serif; color: var(--text); 
        }

        /* MODULAR INTERFACE */
        #setup-ui { min-height: 100vh; padding: 40px; display: none; box-sizing: border-box;; }
        .bento-grid { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
        .card { background: var(--card); padding: 24px; border-radius: 16px; border: 1px solid #333; transition: border-color 0.2s ease; }
        .card:hover { border-color: var(--accent); }
        .full-width { grid-column: span 3; }
        .header-card { padding: 25px; display: flex; flex-direction: column; align-items: center; text-align: center; justify-content: center; min-height: auto; }
        h1, h3 { color: var(--accent); margin-top: 0; letter-spacing: -0.5px; }
        h1 { font-size: 1.6em; margin-bottom: 5px; }
        h3 { font-size: 1.1em; margin-bottom: 15px; }
        label { display: block; font-weight: 600; margin-bottom: 4px; color: var(--muted); font-size: 0.75em; text-transform: uppercase; }

        /* INTERACTIVE INPUTS */
        input, select, textarea, button { padding: 14px; width: 100%; border-radius: 10px; border: 1px solid #444; background: #252525; color: white; margin-bottom: 12px; box-sizing: border-box; font-size: 14px; }
        input[type="color"] { height: 45px; padding: 2px; }
        button { background: var(--accent); color: #000; font-weight: 800; border: none; cursor: pointer; text-transform: uppercase; transition: 0.2s; }
        button:hover { background: #fff; transform: scale(1.02); }
        .download-btn { background: var(--success); color: white; margin-top: 5px; }
        .download-btn:hover { color: var(--success) };
        .upload-row { display: flex; align-items: center; justify-content: space-between; background: #252525; padding: 8px 12px; border-radius: 8px; margin-bottom: 8px; border: 1px solid #444; font-size: 0.85em; }
        .del-btn { width: auto !important; padding: 4px 10px !important; margin: 0 !important; background: var(--err) !important; color: white !important; font-size: 11px !important; }

        /* PREVIEW & OUTPUT */
        #preview-window { border: 2px dashed #444; border-radius: 16px; height: 320px; position: relative; overflow: hidden; background: #000; }
        .output-box { background: #000; color: #00ff41; padding: 12px; border-radius: 10px; font-family: monospace; word-break: break-all; border: 1px solid #333; max-height: 80px; overflow-y: auto; font-size: 0.75em; margin-bottom: 15px; cursor: copy; }
        .url-warning { color: var(--err); font-size: 0.8em; margin-top: -10px; margin-bottom: 10px; display: none; line-height: 1.4; }

        /* GPU ANIMATIONS */
        #bouncing-image { position: absolute; display: none; pointer-events: none; will-change: transform; transform-origin: top left; }
        @keyframes shake { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(4px,4px); } 50% { transform: translate(-4px,-4px); } }
        .shake-active { animation: shake 0.1s infinite !important; }
        .invert-active { filter: invert(1); }
        .zoom-active { transform: scale(1.7) !important; transition: transform 0.1s ease-out; }

        @media (max-width: 900px) {
            .bento-grid { grid-template-columns: 1fr; }
            .full-width { grid-column: span 1; }
        }
    </style>
</head>
<body>

    <!-- UI: SETUP INTERFACE -->
    <div id="setup-ui">
        <div class="bento-grid">
            <div class="card header-card full-width">
                <h1>Bouncing Image Generator (DVD Logo Style)</h1>
                <p style="color: var(--muted); font-size: 0.9em; margin: 0;">Free GIF & streaming overlay generator by GeminiGhostSymphony.</p>
            </div>

            <!-- ASSETS -->
            <div class="card">
                <h3>Image Assets</h3>
                <label>Image URLs (one per line)</label>
                <textarea id="urlInput" rows="2" placeholder="Paste URLs here..."></textarea>
                <label>Upload Images (DO NOT use for overlay, only for GIF & preview)</label>
                <div id="file-input-container">
                    <input type="file" class="file-input-row" accept="image/*" multiple>
                </div>
                <button class="clear-btn" onclick="clearLocalAssets()">Clear All Local Uploads</button>
            </div>

            <!-- BEHAVIOR -->
            <div class="card">
                <h3>Effects & Speeds Settings</h3>
                <label>Corner Hit Celebration Effect</label>
                <select id="effectType">
                    <option value="none">No Celebration</option>
                    <option value="flash">Screen Flash</option>
                    <option value="shake">Screen Shake</option>
                    <option value="invert">Color Invert</option>
                    <option value="rainbow">Rainbow Cycle</option>
                    <option value="zoom">Zoom-in</option>
                    <option value="random">Random Selection of Above</option>
                </select>
                <button onclick="testCelebrationUI()">Test Selected Effect</button>
                <div style="display:flex; gap:10px;">
                    <div style="flex:1;"><label>Speed</label><input type="number" id="imgSpeed" value="15" step="1" min="0" oninput="if(this.value<0)this.value=0"></div>
                </div>
                <div style="display:flex; gap:10px;">
                    <div style="flex:1;"><label>Swap Time (Seconds, 0 = Every Hit)</label><input type="number" id="switchTime" value="0" step="0.5" min="0" oninput="if(this.value<0)this.value=0"></div>
                </div>
            </div>

            <!-- GIF EXPORT -->
            <div class="card">
                <h3>GIF Export</h3>
                <label>Background Color</label>
                <input type="color" id="gifBg" value="#000000">
                <label>Duration (Seconds, Max 10)</label>
                <input type="number" id="gifDuration" value="5" min="1" max="10">
                <button onclick="exportToGif()" id="gifBtn">Download GIF</button>
            </div>

            <!-- PREVIEW & EXPORT -->
            <div class="card full-width">
                <h3>Preview & Stream Export</h3>
                <div id="preview-window"><div id="preview-msg" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#444;">Add an image to begin preview.</div></div>
                <button onclick="generateContent()" style="margin-top:20px;">Generate/Update Stream Overlay Package</button>
                <div id="results-area" style="display:none; margin-top: 25px;">
                    <div id="lenWarning" class="url-warning">⚠️ URL too long! Use Web URLs instead of file uploads or use "Download Launcher" button below.</div>
                    <label>Browser Source URL (Length: <span id="urlCount">0</span>)</label>
                    <div id="generated-url" class="output-box" onclick="copyText(this)"></div>
                    <small style="color: var(--muted); display: block; margin-top: -5px; margin-bottom: 15px;">(Click box above to copy URL to clipboard)</small>
                    <label>Dynamic Custom CSS</label>
                    <div id="generated-css" class="output-box" onclick="copyText(this)"></div>
                    <small style="color: var(--muted); display: block; margin-top: -5px; margin-bottom: 15px;">(Click box above to copy URL to clipboard)</small>
                    <label>For overlays, download the HTML file below and import into streaming software as a browser source with the above CSS.</label>
                    <button class="download-btn" onclick="downloadFile()">Download Launcher HTML</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ACTIVE OVERLAY ELEMENT -->
    <img id="bouncing-image" src="" alt="Bouncing Image">

    <script>
        // INITIALIZATION & ROUTING
        const params = new URLSearchParams(window.location.search);
        const img = document.getElementById('bouncing-image');
        let currentImages = []; 
        let localAssets = []; // Storage for local file data
        let lastFrameTime = performance.now();
        let animationId = null; // Track animation to prevent duplicates

        if (params.has('imgs')) { 
            if (params.has('m')) {
                const maxSize = params.get('m') + 'px';
                img.style.maxWidth = maxSize;
                img.style.maxHeight = maxSize;
                img.style.objectFit = 'contain';
            }
            startLiveMode(false); 
        } else { 
            document.getElementById('setup-ui').style.display = 'block'; 
            // Automatically update listeners
            ['urlInput', 'imgSpeed', 'switchTime', 'effectType'].forEach(id => {
                document.getElementById(id).addEventListener('input', generateContent);
            });
            initFileInput(document.querySelector('.file-input-row'));
            document.getElementById('urlInput').addEventListener('input', generateContent);
            document.getElementById('imgSpeed').addEventListener('input', generateContent);
            document.getElementById('switchTime').addEventListener('input', generateContent);
            document.getElementById('effectType').addEventListener('input', generateContent);
        }

        function initFileInput(el) {
            el.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    // Create a unique group for these specific blobs
                    const blobGroup = files.map(f => URL.createObjectURL(f));
                    
                    // Create a UI wrapper for the delete button
                    const wrapper = document.createElement('div');
                    wrapper.className = 'upload-row'; 
                    wrapper.draggable = true;
                    wrapper.dataset.blobs = JSON.stringify(blobGroup); 
                    wrapper.style.padding = '12px';
                    wrapper.style.marginBottom = '10px';
                    wrapper.style.border = '1px solid #444';
                    wrapper.style.borderRadius = '8px';
                    wrapper.style.background = '#252525';
                    wrapper.style.display = 'flex';
                    wrapper.style.alignItems = 'center';
                    wrapper.style.justifyContent = 'space-between';
        
                    wrapper.innerHTML = `<span style="font-size: 0.9em; color: var(--text);">Uploaded ${files.length} file(s)</span>`;
                    
                    const delBtn = document.createElement('button');
                    delBtn.innerText = "Delete";
                    delBtn.className = "del-btn";
                    delBtn.style.width = 'auto';
                    delBtn.style.padding = '6px 12px';
                    delBtn.style.margin = '0';
                    delBtn.style.background = 'var(--err)';
                    delBtn.onclick = () => {
                        // Remove these specific blobs from the global list
                        localAssets = localAssets.filter(asset => !blobGroup.includes(asset));
                        blobGroup.forEach(url => URL.revokeObjectURL(url));
                        wrapper.remove();
                        
                        syncAndRefresh();
                    };

                    wrapper.ondragstart = (e) => { e.dataTransfer.setData('text/plain', null); wrapper.style.opacity = '0.5'; };
                    wrapper.ondragend = () => { wrapper.style.opacity = '1'; syncAndRefresh(); };
                    wrapper.ondragover = (e) => {
                        e.preventDefault();
                        const container = document.getElementById('file-input-container');
                        const dragging = document.querySelector('.upload-row[style*="opacity: 0.5"]');
                        if (!dragging || dragging === wrapper) return;
                        
                        const children = [...container.querySelectorAll('.upload-row')];
                        const currIdx = children.indexOf(wrapper);
                        const dragIdx = children.indexOf(dragging);
                        
                        if (currIdx > dragIdx) wrapper.after(dragging);
                        else wrapper.before(dragging);
                    };
                    
                    wrapper.appendChild(delBtn);
                    const container = document.getElementById('file-input-container');
                    container.insertBefore(wrapper, container.firstChild);

                    el.value = null;
                    el.style.display = 'none';
        
                    // Create the next fresh input row
                    const next = document.createElement('input');
                    next.type = 'file'; next.className = 'file-input-row'; 
                    next.accept = 'image/*'; next.multiple = true;
                    initFileInput(next); 
                    document.getElementById('file-input-container').appendChild(next);

                    currentImages = [...localAssets];

                    syncAndRefresh();
                }
            });
        }

        // REFRESH AND SYNC IMAGES
        function syncAndRefresh() {
            const container = document.getElementById('file-input-container');
            const rows = [...container.querySelectorAll('.upload-row')];
            localAssets = rows.flatMap(row => JSON.parse(row.dataset.blobs));
            
            // Refresh the preview
            generateContent();
        }

        // ASSET MANAGEMENT
        function clearLocalAssets() {
            const container = document.getElementById('file-input-container');
            const rows = container.querySelectorAll('.upload-row');
            rows.forEach(row => {
                const blobs = JSON.parse(row.dataset.blobs);
                blobs.forEach(url => URL.revokeObjectURL(url));
                row.remove();
            });
            
            localAssets = [];
            syncAndRefresh();
        }

        // GENERATOR LOGIC
        async function generateContent() {
            const urlInput = document.getElementById('urlInput');
            const webUrls = urlInput ? urlInput.value.split('\n').map(u => u.trim()).filter(u => u !== "") : [];
            const pMsg = document.getElementById('preview-msg');
            let pImg = document.getElementById('preview-img');

            currentImages = [...localAssets, ...webUrls];
            
            if (!currentImages.length) {
                if (pMsg) pMsg.style.display = 'block';
                if (animationId) cancelAnimationFrame(animationId);
                if (pImg) {
                    pImg.style.display = 'none';
                    pImg.src = ""; 
                }
                document.getElementById('results-area').style.display = 'none';
                return;
            }

            if (!pImg) {
                const windowDiv = document.getElementById('preview-window');
                windowDiv.innerHTML = '<img id="preview-img" style="position:absolute; max-width:200px; max-height: 200px; object-fit: contain; will-change:transform; transform-origin: top left;">';
                pImg = document.getElementById('preview-img');
            }

            pImg.style.display = 'block';
            pImg.src = currentImages[0];

            const settings = {
                imgs: encodeURIComponent(JSON.stringify(currentImages)),
                v: document.getElementById('imgSpeed').value,
                e: document.getElementById('effectType').value,
                t: document.getElementById('switchTime').value,
                m: 200
            };

            const finalUrl = `${window.location.origin}${window.location.pathname}?imgs=${settings.imgs}&v=${settings.v}&e=${settings.e}&t=${settings.t}&m=${settings.m}`;
            document.getElementById('generated-url').innerText = finalUrl;
            document.getElementById('urlCount').innerText = finalUrl.length;
            document.getElementById('lenWarning').style.display = finalUrl.length > 4000 ? 'block' : 'none';
            
            // Dynamic CSS logic
            let css = `html, body { margin: 0; padding: 0; overflow: hidden; background-color: rgba(0,0,0,0) !important; } #bouncing-image { position: absolute; will-change: transform; transform-origin: top left; max-width: 200px !important; max-height: 200px !important; object-fit: contain;}`;
            if (settings.e === 'shake') css += `\n.shake-active { animation: shake 0.1s infinite !important; }\n@keyframes shake { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(4px,4px); } 50% { transform: translate(-4px,-4px); } }`;
            if (settings.e === 'invert') css += `\n.invert-active { filter: invert(1); }`;
            if (settings.e === 'zoom') css += `\n.zoom-active { transform: scale(1.4) !important; transition: transform 0.1s ease-out; }`;
            if (settings.e === 'random') css += `\n.shake-active { animation: shake 0.1s infinite !important; }\n@keyframes shake { 0%, 100% { transform: translate(0,0); } 25% { transform: translate(4px,4px); } 50% { transform: translate(-4px,-4px); } }\n.invert-active { filter: invert(1); }\n.zoom-active { transform: scale(1.4) !important; transition: transform 0.1s ease-out; }`;
            document.getElementById('generated-css').innerText = css;
            
            document.getElementById('results-area').style.display = 'block';
            if (pMsg) pMsg.style.display = 'none';

            startLiveMode(true, settings, currentImages);
        }

        // GIF EXPORT
        async function exportToGif() {
            if (!currentImages.length) return alert("Add images first.");
            const btn = document.getElementById('gifBtn');
            const originalText = "Download GIF";
            btn.innerText = "Encoding..."; btn.disabled = true;

            const duration = Math.min(document.getElementById('gifDuration').value, 10);
            const bgColor = document.getElementById('gifBg').value;

            try {
                // Fetch worker code and create a local Blob
                const response = await fetch('https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js');
                if (!response.ok) throw new Error("Worker fetch failed");
                const workerCode = await response.text();
                const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(workerBlob);

                // Dynamically determine canvas size
                const preSpeed = parseFloat(document.getElementById('imgSpeed').value) || 15;
                const preDuration = 5; 
                const idealSize = Math.round(((preSpeed * 8 * preDuration) / 2) + 40 + 200);
                const finalW = Math.max(400, Math.min(1000, idealSize));
                const finalH = Math.max(400, Math.min(1000, idealSize));

                const gif = new GIF({ 
                    workers: 2, quality: 1, width: 800, height: 600, 
                    workerScript: workerUrl, dither: 'FloydSteinberg'
                });

                const tempCanvas = document.createElement('canvas');
                const ctx = tempCanvas.getContext('2d');
                tempCanvas.width = finalW; tempCanvas.height = finalH;

                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                const loadImages = currentImages.map(url => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = "Anonymous";
                        img.onload = () => resolve(img);
                        img.src = url;
                    });
                });

                const loadedImgs = await Promise.all(loadImages);

                let imgIdx = 0;
                let currentLogo = loadedImgs[imgIdx];
                let lastSwapTime = 0; // Simulated seconds
                const startX = 40, startY = 40;
                let x = startX, y = startY, dx = 1, dy = 1;
  
                const delay = 30; 
                const dt = delay / 1000; 

                const totalDuration = 5;
                const totalFrames = Math.round((totalDuration * 1000) / delay);
                
                for (let i = 0; i < totalFrames; i++) {
                    const loopSpeed = parseFloat(document.getElementById('imgSpeed').value) || 15;
                    const loopDuration = 5;
                    const loopDt = 30 / 1000;
                    const loopSimTime = i * loopDt;
                    const targetSize = 200;
                    const loopStartX = 40, loopStartY = 40;
                    const swapSecs = parseFloat(document.getElementById('switchTime').value) || 0;

                    let currentLogo = loadedImgs[imgIdx];
                    const ratio = currentLogo.naturalWidth / currentLogo.naturalHeight;
                    let iw = ratio > 1 ? targetSize : targetSize * ratio;
                    let ih = ratio > 1 ? targetSize / ratio : targetSize;

                    const adjustedVX = ((finalW - iw - loopStartX) * 2) / loopDuration;
                    const adjustedVY = ((finalH - ih - loopStartY) * 2) / loopDuration;
        
                    x += dx * adjustedVX * loopDt;
                    y += dy * adjustedVY * loopDt;

                    if (x + iw >= finalW) { dx = -1; x = finalW - iw; } 
                    else if (x <= 0) { dx = 1; x = 0; }
                    if (y + ih >= finalH) { dy = -1; y = finalH - ih; } 
                    else if (y <= 0) { dy = 1; y = 0; }
        
                    // Swap Logic
                    const shouldSwap = (swapSecs === 0 && (x <= 0 || x + iw >= finalW || y <= 0 || y + ih >= finalH)) || 
                                       (swapSecs > 0 && (loopSimTime - lastSwapTime) >= swapSecs);
                    if (shouldSwap && loadedImgs.length > 1) {
                        imgIdx = (imgIdx + 1) % loadedImgs.length;
                        lastSwapTime = loopSimTime;
                    }
                    
                    ctx.fillStyle = document.getElementById('gifBg').value; 
                    ctx.fillRect(0,0,800,600);

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.drawImage(currentLogo, 0, 0, iw, ih);
                    ctx.restore();
                    
                    gif.addFrame(ctx, { copy: true, delay: delay });
                }
                    
                gif.on('finished', (blob) => {
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); 
                    a.download = 'image-bounce.gif'; a.click();
                    URL.revokeObjectURL(workerUrl); 
                    btn.innerText = originalText; btn.disabled = false;
                });
                    
                gif.render();
            } catch (err) { alert("GIF Error: " + err); btn.innerText = "Download GIF"; btn.disabled = false; }
        }

        // ANIMATION 
        function startLiveMode(isPreview, settings = null, imagesArr = null) {
            // Cancel any existing animation to prevent overlap
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            lastFrameTime = 0;
            
            const targetImg = isPreview ? document.getElementById('preview-img') : img;
            
            const container = isPreview ? document.getElementById('preview-window') : window;

            const liveContainer = document.getElementById('live-container');
            if (liveContainer) {
                liveContainer.style.display = isPreview ? 'none' : 'block';
            }
            
            if (targetImg) targetImg.style.display = 'block';

            const imgs = imagesArr || JSON.parse(decodeURIComponent(params.get('imgs')));
            const effect = settings?.e || params.get('e');
            const swap = parseInt(settings?.t || params.get('t')) || 0;

            let x = 20, y = 20, dx = 1, dy = 1, idx = 0, slow = false, lastSw = Date.now();
            targetImg.crossOrigin = "anonymous";
            targetImg.style.display = 'block';
            targetImg.src = imgs[idx];

            function animate(now) {
                if (!lastFrameTime) {
                    lastFrameTime = now;
                    animationId = requestAnimationFrame(animate);
                    return;
                }
                const dt = Math.min((now - lastFrameTime) / 1000, 0.1); // Cap dt to prevent jumps
                lastFrameTime = now;

                const w = isPreview ? container.clientWidth : window.innerWidth;
                const h = isPreview ? container.clientHeight : window.innerHeight;
                const iw = targetImg.clientWidth || 80;
                const ih = targetImg.clientHeight || 80;

                const rawSpeed = isPreview 
                    ? (parseFloat(document.getElementById('imgSpeed').value)) 
                    : (parseFloat(params.get('v')));
                
                const baseSpeed = isNaN(rawSpeed) ? 15 : rawSpeed;

                const velocity = baseSpeed * (w / 1000); 

                if (baseSpeed > 0) {
                    x += dx * velocity * dt * 10;
                    y += dy * velocity * dt * 10;
                }
                
                let hX = (x + iw >= w || x <= 0);
                let hY = (y + ih >= h || y <= 0);
                
                if (hX && hY) triggerCelebration(effect, isPreview ? container : document.body, targetImg, (s) => slow = s);
                
                if (hX) { dx = -dx; x = Math.max(0, Math.min(x, w - iw)); }
                if (hY) { dy = -dy; y = Math.max(0, Math.min(y, h - ih)); }
        
                const activeImgs = isPreview ? currentImages : imgs;
                const swapSecs = isPreview ? (parseFloat(document.getElementById('switchTime').value) || 0) : (parseFloat(params.get('t')) || 0);
                const timePassed = (Date.now() - lastSw) / 1000;
        
                if ((swapSecs === 0 && (hX || hY)) || (swapSecs > 0 && timePassed >= swapSecs)) {
                    if (activeImgs.length > 1) { 
                        idx = (idx + 1) % activeImgs.length; 
                        targetImg.src = activeImgs[idx]; 
                        lastSw = Date.now(); 
                    }
                }
                
                targetImg.style.transform = `translate3d(${x.toFixed(3)}px, ${y.toFixed(3)}px, 0.001px)`;
                animationId = requestAnimationFrame(animate);
            }
        
            const start = () => {
                // Prevent multiple loops from starting if onload fires after a 'complete' check
                if (animationId) cancelAnimationFrame(animationId);
                lastFrameTime = performance.now();
                animationId = requestAnimationFrame(animate);
            };
        
            // Set the onload listener before setting .src to ensure it catches the event
            if (targetImg.complete && targetImg.naturalWidth > 0) {
                start();
            } else {
                targetImg.onload = start;
            }
            
            targetImg.src = imgs[idx];
        }

        // CELEBRATION TRIGGER
        function triggerCelebration(t, b, i, setS) {
            const effects = ['flash', 'shake', 'invert', 'rainbow', 'zoom'];
            const sel = t === 'random' ? effects[Math.floor(Math.random() * effects.length)] : t;

            const resetColor = (b.id === 'preview-window') ? '#000000' : 'transparent';
            
            if (sel === 'flash') { b.style.backgroundColor = 'white'; setTimeout(() => b.style.backgroundColor = resetColor, 150); }
            else if (sel === 'shake') { b.classList.add('shake-active'); setTimeout(() => b.classList.remove('shake-active'), 500); }
            else if (sel === 'invert') { i.classList.add('invert-active'); setTimeout(() => i.classList.remove('invert-active'), 400); }
            else if (sel === 'zoom') { setS(true); i.classList.add('zoom-active'); setTimeout(() => { setS(false); i.classList.remove('zoom-active'); }, 1000); }
            else if (sel === 'rainbow') {
                let c = 0, colors = ['#ff0000', '#ffa500', '#ffff00', '#008000', '#0000ff', '#4b0082'];
                let iv = setInterval(() => { b.style.backgroundColor = colors[c++]; if (c >= colors.length) { clearInterval(iv); b.style.backgroundColor = resetColor; } }, 120);
            }
        }

        // CELEBRATION TEST IN UI
        function testCelebrationUI() {
            const effect = document.getElementById('effectType').value;
            const previewContainer = document.getElementById('preview-window');
            const previewImg = document.getElementById('preview-img');
            
            if (effect === 'none') return;
            if (!previewImg || previewImg.style.display === 'none') {
                alert("Please add an image first to test effects.");
                return;
            }
        
            triggerCelebration(
                effect, 
                previewContainer, 
                previewImg, 
                (s) => { }
            );
        }

        // UTILITIES
        function copyText(el) {
            navigator.clipboard.writeText(el.innerText);
            el.style.borderColor = "#00ff41"; // Active link verification
            setTimeout(() => el.style.borderColor = '#333', 600);
        }

        function downloadFile() {
            const url = document.getElementById('generated-url').innerText;
            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <style>
                        html, body { background: transparent !important; margin: 0; padding: 0; overflow: hidden; }
                        #bouncing-image { max-width: 200px !important; max-height: 200px !important; object-fit: contain; }
                    </style>
                </head>
                <body style="margin:0; overflow:hidden; background:transparent;">
                    <script>window.location.replace("${url}");<\/script>
                </body>
                </html>`;
            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
            a.download = 'StreamImageBouncerOverlay.html'; a.click();
        }
        
    </script>
</body>
</html>
